package com.wcci.reviews.restControllers;

import com.wcci.reviews.entities.Category;
import com.wcci.reviews.entities.HashTag;
import com.wcci.reviews.entities.Review;
import com.wcci.reviews.respositories.CategoryRepository;
import com.wcci.reviews.respositories.HashTagRepository;
import com.wcci.reviews.respositories.ReviewRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.Optional;

@RestController
@CrossOrigin // Don't be picky about which javascript is hitting these endpoints
public class ReviewController {
    final ReviewRepository reviewRepository;
    final HashTagRepository tagRepository;
    final CategoryRepository categoryRepository;

    public ReviewController(
            // The @Autowired is polite but Spring knows it anyway
            final @Autowired ReviewRepository reviewRepository,
            final @Autowired HashTagRepository tagRepository,
            final @Autowired CategoryRepository categoryRepository) {
        this.reviewRepository = reviewRepository;
        this.tagRepository = tagRepository;
        this.categoryRepository = categoryRepository;
    }

    @GetMapping("/reviews")
    public Iterable<Review> getReviews() {
        return reviewRepository.findAll();

        // This doesn't return a List<Review>, but you can pretend it does.
        // And a List can contain 1 element, or 2, or 100, or zero.
        // So the special case where there are no reviews doesn't require anything special.
    }

    // Hey spring, if you see an endpoint like /reviews/anynumber, use this code
    @GetMapping("/reviews/{review_id}")
    public Review getReviewByID(final @PathVariable long review_id) {
        final Optional<Review> perhapsReview = reviewRepository.findById(review_id);
        return perhapsReview
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Cannot find review " + review_id));

        // Lets imagine that /review/1 exists but /review/2 doesn't, what should getReviewByID:
        // this method should either return an actual Review, or die trying.
    }

    @GetMapping("/reviews/{oneReviewID}/tags")
    public Optional<Iterable<HashTag>> getTagsForReviewByID(final @PathVariable long oneReviewID) {
        return reviewRepository.findById(oneReviewID)
                .map((review) -> review.getTags());
    }

    @PostMapping("/reviews/{review_id}/tags/{tag_id}")
    public void addTagToReview(
            final @PathVariable long review_id,
            final @PathVariable String tag_id) {
        final HashTag tag = tagRepository
                .findById(tag_id)
                .orElseGet(() -> tagRepository.save(new HashTag(tag_id)));

        final Optional<Review> reviewByID = reviewRepository.findById(review_id);
        reviewByID.map((final Review review) -> {
            review.getTags().add(tag);
            return reviewRepository.save(review);
        });
    }

    @DeleteMapping("/reviews/{review_id}/tags/{tag_id}")
    public void removeTagFromReview(
            final @PathVariable long review_id,
            final @PathVariable String tag_id) throws Exception {
        final HashTag tag = tagRepository.findById(tag_id)
                .orElseThrow(() -> new Exception("Unable to find tag: " + tag_id));

        final Optional<Review> reviewByID = reviewRepository.findById(review_id);
        reviewByID.map((final Review review) -> {
            review.removeTag(tag);
            return reviewRepository.save(review);
        });
    }

    @PostMapping("/reviews")
    public Review postReview(final @RequestBody Review review) {
        // We've just received a Review we need to insert into the database.
        // Review has an AutoGenerated .id field so we can always add a new review, even if it
        // similiar to an existing review.

        // BUT...that review contains a Category which:
        //   * Might be a new category --> we need to write this category to the Categories table
        //   * Might be an existing category --> we should not write this category to the Categories table
        final String categoryName = review.getCategory().getName();
        final Optional<Category> perhapsExistingCategory = categoryRepository.findById(categoryName);

        if (perhapsExistingCategory.isEmpty()) {
            // When Review had `@Cascade(org.hibernate.annotations.CascadeType.PERSIST)` on its category field,
            // this happened *every time* automatically, whether or not the category already existed.
            categoryRepository.save(review.getCategory());
        }

        for (final HashTag tag : review.getTags()) {
            final Optional<HashTag> perhapsExistingTag = tagRepository.findById(tag.getName());

            if (perhapsExistingTag.isEmpty()) {
                tagRepository.save(tag);
            }
        }

        // Now that any necessary tags and categories have been created, it is now safe to save the review itself
        return reviewRepository.save(review);
    }

    @PutMapping("/reviews/{review_id}")
    public void putReview(@PathVariable final long review_id, final @RequestBody Review review) throws Exception {
        if (review.getId() != review_id)
            throw new Exception("Review body has id " + review.getId() + " but url had id " + review_id);
        reviewRepository.save(review);
    }

    @DeleteMapping("/reviews/{review_id}")
    public void deleteReview(@PathVariable final long review_id) {
        final Review review = reviewRepository.findById(review_id).orElseThrow(
                () -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Cannot delete nonexistent review " + review_id));

        reviewRepository.delete(review);
    }
}
